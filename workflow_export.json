{
  "name": "YouTube Anki v2",
  "nodes": [
    {
      "parameters": {
        "jsCode": "// YouTube URLì—ì„œ Video ID ì¶”ì¶œ\nconst input = $input.first().json;\n// ë‹¤ì–‘í•œ ì…ë ¥ í˜•ì‹ ì§€ì›\nconst url = input.body?.youtubeUrl || input.body?.youtube_url || input.youtubeUrl || input.youtube_url || '';\n\n// Video ID ì¶”ì¶œ (ë‹¤ì–‘í•œ YouTube URL í˜•ì‹ ì§€ì›)\nlet videoId = '';\nconst patterns = [\n  /(?:youtube\\.com\\/watch\\?v=)([^&]+)/,\n  /(?:youtu\\.be\\/)([^?]+)/,\n  /(?:youtube\\.com\\/embed\\/)([^?]+)/,\n  /(?:youtube\\.com\\/v\\/)([^?]+)/\n];\n\nfor (const pattern of patterns) {\n  const match = url.match(pattern);\n  if (match) {\n    videoId = match[1];\n    break;\n  }\n}\n\nif (!videoId) {\n  throw new Error('Invalid YouTube URL: ' + url);\n}\n\nreturn [{ json: { videoId, originalUrl: url } }];"
      },
      "id": "extract-video-id",
      "name": "Extract Video ID",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        800,
        100
      ]
    },
    {
      "parameters": {
        "url": "={{ 'http://127.0.0.1:8767/transcript?videoId=' + $json.videoId }}",
        "options": {}
      },
      "id": "get-transcript",
      "name": "Get YouTube Transcript",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1050,
        100
      ]
    },
    {
      "parameters": {
        "jsCode": "// YouTube Transcriptë¥¼ ë¬¸ì¥ ë‹¨ìœ„ë¡œ íŒŒì‹± (ì§§ì€ ë¬¸ì¥ìœ¼ë¡œ ë¶„ë¦¬)\nconst transcriptResponse = $input.first().json;\n\nif (!transcriptResponse.success || !transcriptResponse.transcript) {\n  throw new Error(\"Failed to get transcript: \" + JSON.stringify(transcriptResponse));\n}\n\nconst transcriptItems = transcriptResponse.transcript;\nconst videoId = transcriptResponse.videoId || \"\";\n\n// ì„¤ì •: ë¬¸ì¥ ê¸¸ì´ ì œí•œ\nconst MAX_WORDS = 15;  // ìµœëŒ€ ë‹¨ì–´ ìˆ˜\nconst MAX_TIME_GAP = 2.5;  // ìµœëŒ€ ì‹œê°„ ê°„ê²© (ì´ˆ)\n\n// ë¬¸ì¥ìœ¼ë¡œ í•©ì¹˜ê¸° (ì§§ê²Œ ìœ ì§€)\nconst sentences = [];\nlet currentSentence = \"\";\nlet currentStart = 0;\nlet lastEnd = 0;\n\nfunction countWords(text) {\n  return text.trim().split(/\\s+/).filter(w => w.length > 0).length;\n}\n\nfunction saveSentence(text, start) {\n  const trimmed = text.trim();\n  if (trimmed && countWords(trimmed) >= 3) {  // ìµœì†Œ 3ë‹¨ì–´ ì´ìƒ\n    sentences.push({\n      index: sentences.length,\n      text: trimmed,\n      start: start\n    });\n  }\n}\n\nfor (const item of transcriptItems) {\n  const text = item.text.replace(/\\n/g, \" \").trim();\n  const itemStart = item.start;\n  const itemDuration = item.duration || 2;\n  const itemEnd = itemStart + itemDuration;\n  \n  // ì‹œê°„ ê°„ê²©ì´ í¬ë©´ ìƒˆ ë¬¸ì¥ ì‹œì‘\n  const timeGap = currentSentence ? (itemStart - lastEnd) : 0;\n  \n  if (currentSentence && timeGap > MAX_TIME_GAP) {\n    saveSentence(currentSentence, currentStart);\n    currentSentence = \"\";\n  }\n  \n  // ë¬¸ì¥ ì‹œì‘\n  if (!currentSentence) {\n    currentStart = itemStart;\n  }\n  \n  // í…ìŠ¤íŠ¸ ì¶”ê°€\n  currentSentence += \" \" + text;\n  lastEnd = itemEnd;\n  \n  // ë§ˆì¹¨í‘œë¡œ ëë‚˜ë©´ ë¬¸ì¥ ì¢…ë£Œ\n  if (text.match(/[.!?]$/)) {\n    saveSentence(currentSentence, currentStart);\n    currentSentence = \"\";\n    continue;\n  }\n  \n  // ë‹¨ì–´ ìˆ˜ê°€ ì´ˆê³¼í•˜ë©´ ìì—°ìŠ¤ëŸ¬ìš´ ëŠê¹€ ì°¾ê¸°\n  const wordCount = countWords(currentSentence);\n  if (wordCount >= MAX_WORDS) {\n    // ìì—°ìŠ¤ëŸ¬ìš´ ëŠê¹€ íŒ¨í„´ (ì ‘ì†ì‚¬, ì½¤ë§ˆ ë“±)\n    const breakPatterns = [\n      /,\\s*(and|but|or|so|because|when|if|that|which|who|where|while|although|however)\\s/gi,\n      /,\\s/g,\n      /\\s(and|but|or|so)\\s/gi\n    ];\n    \n    let broken = false;\n    for (const pattern of breakPatterns) {\n      const matches = [...currentSentence.matchAll(pattern)];\n      if (matches.length > 0) {\n        // ë§ˆì§€ë§‰ ë§¤ì¹˜ ì§€ì ì—ì„œ ìë¥´ê¸°\n        const lastMatch = matches[matches.length - 1];\n        const breakPoint = lastMatch.index + lastMatch[0].indexOf(lastMatch[0].trim());\n        \n        if (breakPoint > currentSentence.length * 0.4) {  // 40% ì´í›„ì—ì„œë§Œ ìë¥´ê¸°\n          const firstPart = currentSentence.substring(0, breakPoint).trim();\n          const secondPart = currentSentence.substring(breakPoint).trim();\n          \n          saveSentence(firstPart, currentStart);\n          currentSentence = secondPart;\n          currentStart = itemStart;  // ëŒ€ëµì ì¸ ì‹œì‘ ì‹œê°„\n          broken = true;\n          break;\n        }\n      }\n    }\n    \n    // ìì—°ìŠ¤ëŸ¬ìš´ ëŠê¹€ì´ ì—†ìœ¼ë©´ ê·¸ëƒ¥ ì €ì¥\n    if (!broken && wordCount >= MAX_WORDS + 5) {\n      saveSentence(currentSentence, currentStart);\n      currentSentence = \"\";\n    }\n  }\n}\n\n// ë‚¨ì€ ë¬¸ì¥ ì €ì¥\nif (currentSentence.trim()) {\n  saveSentence(currentSentence, currentStart);\n}\n\n// Geminiì— ì¸ë±ìŠ¤ì™€ í•¨ê»˜ ì „ë‹¬\nconst indexedSentences = sentences.map(s => `[${s.index}] ${s.text}`);\n\nconst prompt = `You are an expert English teacher specializing in PHRASAL VERBS that native speakers use daily.\n\n## Your Task\nFrom the transcript below, find sentences containing PHRASAL VERBS that are:\n1. Commonly used by native English speakers in everyday conversation\n2. Essential for natural-sounding English\n3. Practical and useful for learners\n\n## What is a Phrasal Verb?\nA phrasal verb = BASE VERB + PARTICLE(s) (preposition/adverb)\nExamples: \"give up\", \"look after\", \"come up with\", \"run out of\"\n\n## Selection Criteria\nâœ… INCLUDE:\n- High-frequency phrasal verbs natives use daily\n- Natural conversational expressions\n- Idiomatically meaningful (meaning changes from literal)\n- Useful in multiple contexts\n\nâŒ EXCLUDE:\n- \"subscribe\", \"click\", \"like this video\" (YouTube spam)\n- Overly technical or rare phrasal verbs\n- Simple verb + preposition that aren't true phrasal verbs\n\n## Important\n- Each sentence has an INDEX in brackets like [0], [1], [2]\n- You MUST return the EXACT index number\n- Select 10-15 best examples\n\n## Response Format (JSON array only):\n[{\n  \"sentence_index\": 5,\n  \"original\": \"exact sentence from transcript (without the [5] prefix)\",\n  \"korean\": \"ìì—°ìŠ¤ëŸ¬ìš´ í•œêµ­ì–´ ë²ˆì—­\",\n  \"base_verb\": \"GET\",\n  \"phrasal_verb\": \"get up\",\n  \"particle\": \"up\",\n  \"literal_meaning\": \"ìœ„ë¡œ ì–»ë‹¤/ê°€ì ¸ê°€ë‹¤\",\n  \"idiomatic_meaning\": \"ì¼ì–´ë‚˜ë‹¤, ê¸°ìƒí•˜ë‹¤ (ê´€ìš©ì  ì˜ë¯¸)\",\n  \"core_image\": \"UPì˜ í•µì‹¬ ì´ë¯¸ì§€: ì™„ì „íˆ ìœ„ë¡œ ì˜¬ë¼ì˜¤ëŠ” ë™ì‘\",\n  \"usage_note\": \"ì•„ì¹¨ì— ì ì—ì„œ ê¹¨ì–´ ì¼ì–´ë‚  ë•Œ ê°€ì¥ ìì£¼ ì‚¬ìš©. 'What time do you usually get up?'\",\n  \"alternatives\": [\"wake up\", \"rise\", \"get out of bed\"],\n  \"formal_equivalent\": \"arise (formal)\",\n  \"example_sentences\": [\n    \"I usually get up at 7 AM.\",\n    \"She got up early to catch the flight.\"\n  ]\n}]\n\n## Field Descriptions:\n- alternatives: 2-3ê°œì˜ ë™ì˜ì–´ ë˜ëŠ” ëŒ€ì²´ í‘œí˜„ (êµ¬ë™ì‚¬ ë˜ëŠ” ë‹¨ì¼ ë™ì‚¬)\n- formal_equivalent: ê²©ì‹ì²´ì—ì„œ ì‚¬ìš©í•˜ëŠ” ë™ë“±í•œ í‘œí˜„ (ìˆëŠ” ê²½ìš°)\n- example_sentences: í•´ë‹¹ êµ¬ë™ì‚¬ë¥¼ ì‚¬ìš©í•œ ì¶”ê°€ ì˜ˆë¬¸ 2ê°œ\n\n## Numbered Sentences from Transcript:\n${indexedSentences.join(\"\\n\")}`;\n\nreturn [{\n  json: {\n    prompt: prompt,\n    sentences: sentences,\n    videoId: videoId\n  }\n}];"
      },
      "id": "parse-transcript",
      "name": "Parse & Group Sentences",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1300,
        100
      ]
    },
    {
      "parameters": {
        "jsCode": "// Gemini APIë¥¼ í˜¸ì¶œí•˜ì—¬ phrasal verb ë¬¸ì¥ í•„í„°ë§\nconst GEMINI_API_KEY = \"YOUR_GEMINI_API_KEY\";\n\nconst inputData = $input.first().json;\nconst prompt = inputData.prompt;\nconst sentences = inputData.sentences;\nconst videoId = inputData.videoId;\n\nconst response = await this.helpers.httpRequest({\n  method: \"POST\",\n  url: `https://generativelanguage.googleapis.com/v1beta/models/gemini-3-flash-preview:generateContent?key=${GEMINI_API_KEY}`,\n  headers: { \"Content-Type\": \"application/json\" },\n  body: {\n    contents: [{ parts: [{ text: prompt }] }],\n    generationConfig: {\n      temperature: 0.3,\n      topK: 20,\n      topP: 0.8,\n      maxOutputTokens: 8192,\n      responseMimeType: \"application/json\"\n    }\n  },\n  json: true\n});\n\nlet filteredSentences = [];\ntry {\n  const textContent = response.candidates[0].content.parts[0].text;\n  \n  try {\n    filteredSentences = JSON.parse(textContent);\n  } catch (parseError) {\n    // JSON ë³µêµ¬ ì‹œë„\n    let fixedJson = textContent.trim();\n    const lastCompleteObj = fixedJson.lastIndexOf('}');\n    if (lastCompleteObj > 0) {\n      fixedJson = fixedJson.substring(0, lastCompleteObj + 1);\n      if (!fixedJson.endsWith(']')) fixedJson += ']';\n      try {\n        filteredSentences = JSON.parse(fixedJson);\n      } catch (e) {\n        const objectPattern = /\\{[^{}]*\"sentence_index\"\\s*:\\s*\\d+[^{}]*\\}/g;\n        const matches = textContent.match(objectPattern);\n        if (matches) {\n          filteredSentences = matches.map(m => {\n            try { return JSON.parse(m); } catch { return null; }\n          }).filter(Boolean);\n        }\n      }\n    }\n  }\n\n  if (!Array.isArray(filteredSentences)) filteredSentences = [];\n  filteredSentences = filteredSentences.filter(s => s && typeof s.sentence_index === 'number' && s.original);\n} catch (e) {\n  filteredSentences = [];\n}\n\n// Fallback: Geminiê°€ ì¶©ë¶„íˆ ë°˜í™˜í•˜ì§€ ì•Šì€ ê²½ìš°\nif (filteredSentences.length < 3) {\n  const phrasalVerbPattern = /(get|take|put|come|go|look|turn|give|make|set|pick|bring|call|cut|break|hold|keep|run|work|figure|check|fill|show|point|end|hang|carry|pull|throw|knock|pass|try|find|sort|back|shut|slow|speed|calm|cheer|clean|clear|close|cool|dress|dry|eat|grow|heat|hurry|light|line|mix|open|pay|pile|roll|save|sell|send|settle|sign|sit|split|stand|start|stay|sum|tidy|wake|warm|watch|wear|wipe|wrap|write|zoom)\\s+(up|down|in|out|on|off|away|back|over|through|around|along|about|across|after|ahead|apart|aside|by|forward|into|onto|together|under|with)/i;\n  \n  filteredSentences = sentences\n    .filter(s => phrasalVerbPattern.test(s.text))\n    .slice(0, 15)\n    .map((s, i) => {\n      const match = s.text.match(phrasalVerbPattern);\n      const pv = match ? match[0] : 'unknown';\n      return {\n        sentence_index: s.index || i,\n        original: s.text,\n        phrasal_verb: pv,\n        korean: \"(ë²ˆì—­ ì¤€ë¹„ ì¤‘)\",\n        literal_meaning: \"(ì§ì—­ ì¤€ë¹„ ì¤‘)\",\n        idiomatic_meaning: \"(ê´€ìš© ì˜ë¯¸ ì¤€ë¹„ ì¤‘)\",\n        core_image: \"(í•µì‹¬ ì´ë¯¸ì§€ ì¤€ë¹„ ì¤‘)\",\n        usage_note: \"(ì‚¬ìš©ë²• ì¤€ë¹„ ì¤‘)\"\n      };\n    });\n}\n\n// ëª¨ë“  ë¬¸ì¥ì— í•„ìˆ˜ í•„ë“œ ê¸°ë³¸ê°’ ë³´ì¥\nfilteredSentences = filteredSentences.map(s => ({\n  ...s,\n  korean: s.korean || \"(ë²ˆì—­ ì—†ìŒ)\",\n  literal_meaning: s.literal_meaning || \"(ì§ì—­ ì—†ìŒ)\",\n  idiomatic_meaning: s.idiomatic_meaning || \"(ê´€ìš© ì˜ë¯¸ ì—†ìŒ)\",\n  core_image: s.core_image || \"(í•µì‹¬ ì´ë¯¸ì§€ ì—†ìŒ)\",\n  usage_note: s.usage_note || \"(ì‚¬ìš©ë²• ì—†ìŒ)\"\n}));\n\nreturn [{\n  json: {\n    filteredSentences: filteredSentences,\n    originalSentences: sentences,\n    videoId: videoId,\n    count: filteredSentences.length\n  }\n}];"
      },
      "id": "gemini-filter",
      "name": "Filter Practical Sentences (Gemini)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1550,
        100
      ]
    },
    {
      "parameters": {
        "jsCode": "// êµ¬ë™ì‚¬ í•˜ì´ë¼ì´íŠ¸ + TTS ì •í™•ë„ ê°œì„  (ë™ì‚¬ í™œìš©í˜• ì§€ì›)\nconst inputData = $input.first().json;\n\nconst sentences = inputData.filteredSentences || [];\nconst originalSentences = inputData.originalSentences || [];\nconst videoId = inputData.videoId || \"\";\n\nif (sentences.length === 0) {\n  return [{ json: { error: \"No sentences found\", videoId: videoId } }];\n}\n\nconst results = [];\nconst GOOGLE_TTS_KEY = \"YOUR_GOOGLE_TTS_API_KEY\";\n\n// íƒ€ì„ìŠ¤íƒ¬í”„ ì°¾ê¸° + ì›ë³¸ ë¬¸ì¥ ê°€ì ¸ì˜¤ê¸°\nfunction findOriginalSentence(sentence, sentenceIndex, originalSentences) {\n  const geminiText = sentence.original || \"\";\n\n  // 1. ì¸ë±ìŠ¤ë¡œ ì§ì ‘ ì¡°íšŒ\n  if (typeof sentenceIndex === 'number' &&\n      sentenceIndex >= 0 &&\n      sentenceIndex < originalSentences.length &&\n      originalSentences[sentenceIndex]) {\n\n    const orig = originalSentences[sentenceIndex];\n    const origText = orig.text || \"\";\n    const origStart = orig.start;\n\n    // ê²€ì¦: ìµœì†Œ 3ë‹¨ì–´ ì´ìƒ ê²¹ì¹˜ëŠ”ì§€\n    const origWords = origText.toLowerCase().split(/\\s+/).filter(w => w.length > 2);\n    const sentWords = geminiText.toLowerCase().split(/\\s+/).filter(w => w.length > 2);\n    let matchCount = 0;\n    for (const w of sentWords.slice(0, 10)) {\n      if (origWords.includes(w)) matchCount++;\n    }\n\n    if (matchCount >= 3) {\n      return {\n        text: origText,\n        timestamp: Math.floor(origStart || 0),\n        method: 'index'\n      };\n    }\n  }\n\n  // 2. Fuzzy ë§¤ì¹­\n  let bestMatch = { score: 0, text: geminiText, timestamp: 0 };\n  const sentWords = geminiText.toLowerCase().replace(/[^a-z\\s]/g, '').split(/\\s+/).filter(w => w.length > 3);\n\n  for (const orig of originalSentences) {\n    if (!orig.text) continue;\n    const origWords = orig.text.toLowerCase().replace(/[^a-z\\s]/g, '').split(/\\s+/);\n\n    let matchCount = 0;\n    for (const w of sentWords) {\n      if (origWords.some(ow => ow.includes(w) || w.includes(ow))) {\n        matchCount++;\n      }\n    }\n\n    const score = sentWords.length > 0 ? matchCount / sentWords.length : 0;\n\n    if (score > bestMatch.score) {\n      bestMatch = {\n        score: score,\n        text: orig.text,\n        timestamp: Math.floor(orig.start || 0)\n      };\n    }\n  }\n\n  if (bestMatch.score >= 0.5) {\n    return { text: bestMatch.text, timestamp: bestMatch.timestamp, method: 'fuzzy' };\n  }\n\n  // 3. í´ë°±\n  return { text: geminiText, timestamp: 0, method: 'fallback' };\n}\n\n// ë™ì‚¬ ì–´ê°„ ì¶”ì¶œ (í™œìš©í˜• ì²˜ë¦¬)\nfunction getVerbStem(verb) {\n  verb = verb.toLowerCase();\n  // ë¶ˆê·œì¹™ ë™ì‚¬ ì²˜ë¦¬\n  const irregulars = {\n    'ran': 'run', 'running': 'run', 'runs': 'run',\n    'got': 'get', 'getting': 'get', 'gets': 'get',\n    'went': 'go', 'going': 'go', 'goes': 'go', 'gone': 'go',\n    'came': 'come', 'coming': 'come', 'comes': 'come',\n    'took': 'take', 'taking': 'take', 'takes': 'take', 'taken': 'take',\n    'put': 'put', 'putting': 'put', 'puts': 'put',\n    'made': 'make', 'making': 'make', 'makes': 'make',\n    'gave': 'give', 'giving': 'give', 'gives': 'give', 'given': 'give',\n    'set': 'set', 'setting': 'set', 'sets': 'set',\n    'brought': 'bring', 'bringing': 'bring', 'brings': 'bring',\n    'thought': 'think', 'thinking': 'think', 'thinks': 'think',\n    'told': 'tell', 'telling': 'tell', 'tells': 'tell',\n    'found': 'find', 'finding': 'find', 'finds': 'find',\n    'left': 'leave', 'leaving': 'leave', 'leaves': 'leave',\n    'held': 'hold', 'holding': 'hold', 'holds': 'hold',\n    'stood': 'stand', 'standing': 'stand', 'stands': 'stand',\n    'kept': 'keep', 'keeping': 'keep', 'keeps': 'keep',\n    'let': 'let', 'letting': 'let', 'lets': 'let',\n    'began': 'begin', 'beginning': 'begin', 'begins': 'begin', 'begun': 'begin',\n    'shown': 'show', 'showing': 'show', 'shows': 'show', 'showed': 'show',\n    'knew': 'know', 'knowing': 'know', 'knows': 'know', 'known': 'know',\n    'grew': 'grow', 'growing': 'grow', 'grows': 'grow', 'grown': 'grow',\n    'threw': 'throw', 'throwing': 'throw', 'throws': 'throw', 'thrown': 'throw',\n    'broke': 'break', 'breaking': 'break', 'breaks': 'break', 'broken': 'break',\n    'spoke': 'speak', 'speaking': 'speak', 'speaks': 'speak', 'spoken': 'speak',\n    'wrote': 'write', 'writing': 'write', 'writes': 'write', 'written': 'write',\n    'drove': 'drive', 'driving': 'drive', 'drives': 'drive', 'driven': 'drive',\n    'ate': 'eat', 'eating': 'eat', 'eats': 'eat', 'eaten': 'eat',\n    'fell': 'fall', 'falling': 'fall', 'falls': 'fall', 'fallen': 'fall',\n    'sat': 'sit', 'sitting': 'sit', 'sits': 'sit',\n    'wore': 'wear', 'wearing': 'wear', 'wears': 'wear', 'worn': 'wear',\n    'cut': 'cut', 'cutting': 'cut', 'cuts': 'cut',\n    'hit': 'hit', 'hitting': 'hit', 'hits': 'hit',\n    'shut': 'shut', 'shutting': 'shut', 'shuts': 'shut',\n    'paid': 'pay', 'paying': 'pay', 'pays': 'pay',\n    'said': 'say', 'saying': 'say', 'says': 'say',\n    'laid': 'lay', 'laying': 'lay', 'lays': 'lay',\n    'heard': 'hear', 'hearing': 'hear', 'hears': 'hear',\n    'sold': 'sell', 'selling': 'sell', 'sells': 'sell',\n    'built': 'build', 'building': 'build', 'builds': 'build',\n    'sent': 'send', 'sending': 'send', 'sends': 'send',\n    'spent': 'spend', 'spending': 'spend', 'spends': 'spend',\n    'lost': 'lose', 'losing': 'lose', 'loses': 'lose',\n    'caught': 'catch', 'catching': 'catch', 'catches': 'catch',\n    'taught': 'teach', 'teaching': 'teach', 'teaches': 'teach',\n    'bought': 'buy', 'buying': 'buy', 'buys': 'buy',\n    'fought': 'fight', 'fighting': 'fight', 'fights': 'fight',\n    'hung': 'hang', 'hanging': 'hang', 'hangs': 'hang',\n    'dug': 'dig', 'digging': 'dig', 'digs': 'dig',\n    'swam': 'swim', 'swimming': 'swim', 'swims': 'swim', 'swum': 'swim',\n    'sank': 'sink', 'sinking': 'sink', 'sinks': 'sink', 'sunk': 'sink',\n    'rang': 'ring', 'ringing': 'ring', 'rings': 'ring', 'rung': 'ring',\n    'sang': 'sing', 'singing': 'sing', 'sings': 'sing', 'sung': 'sing',\n    'sprang': 'spring', 'springing': 'spring', 'springs': 'spring', 'sprung': 'spring',\n    'stuck': 'stick', 'sticking': 'stick', 'sticks': 'stick',\n    'swept': 'sweep', 'sweeping': 'sweep', 'sweeps': 'sweep',\n    'slept': 'sleep', 'sleeping': 'sleep', 'sleeps': 'sleep',\n    'wept': 'weep', 'weeping': 'weep', 'weeps': 'weep',\n    'crept': 'creep', 'creeping': 'creep', 'creeps': 'creep',\n    'felt': 'feel', 'feeling': 'feel', 'feels': 'feel',\n    'dealt': 'deal', 'dealing': 'deal', 'deals': 'deal',\n    'meant': 'mean', 'meaning': 'mean', 'means': 'mean',\n    'led': 'lead', 'leading': 'lead', 'leads': 'lead',\n    'fed': 'feed', 'feeding': 'feed', 'feeds': 'feed',\n    'read': 'read', 'reading': 'read', 'reads': 'read',\n    'spread': 'spread', 'spreading': 'spread', 'spreads': 'spread',\n    'bet': 'bet', 'betting': 'bet', 'bets': 'bet',\n    'burst': 'burst', 'bursting': 'burst', 'bursts': 'burst',\n    'cast': 'cast', 'casting': 'cast', 'casts': 'cast',\n    'cost': 'cost', 'costing': 'cost', 'costs': 'cost',\n    'quit': 'quit', 'quitting': 'quit', 'quits': 'quit',\n    'rid': 'rid', 'ridding': 'rid', 'rids': 'rid',\n    'split': 'split', 'splitting': 'split', 'splits': 'split',\n    'bent': 'bend', 'bending': 'bend', 'bends': 'bend',\n    'lent': 'lend', 'lending': 'lend', 'lends': 'lend',\n    'wound': 'wind', 'winding': 'wind', 'winds': 'wind',\n    'bound': 'bind', 'binding': 'bind', 'binds': 'bind',\n    'ground': 'grind', 'grinding': 'grind', 'grinds': 'grind',\n    'shone': 'shine', 'shining': 'shine', 'shines': 'shine',\n    'spun': 'spin', 'spinning': 'spin', 'spins': 'spin',\n    'won': 'win', 'winning': 'win', 'wins': 'win',\n    'stung': 'sting', 'stinging': 'sting', 'stings': 'sting',\n    'swung': 'swing', 'swinging': 'swing', 'swings': 'swing',\n    'clung': 'cling', 'clinging': 'cling', 'clings': 'cling',\n    'wrung': 'wring', 'wringing': 'wring', 'wrings': 'wring',\n    'stank': 'stink', 'stinking': 'stink', 'stinks': 'stink', 'stunk': 'stink',\n    'drank': 'drink', 'drinking': 'drink', 'drinks': 'drink', 'drunk': 'drink',\n    'shrank': 'shrink', 'shrinking': 'shrink', 'shrinks': 'shrink', 'shrunk': 'shrink',\n    'blew': 'blow', 'blowing': 'blow', 'blows': 'blow', 'blown': 'blow',\n    'flew': 'fly', 'flying': 'fly', 'flies': 'fly', 'flown': 'fly',\n    'drew': 'draw', 'drawing': 'draw', 'draws': 'draw', 'drawn': 'draw',\n    'withdrew': 'withdraw', 'withdrawing': 'withdraw', 'withdraws': 'withdraw', 'withdrawn': 'withdraw',\n    'froze': 'freeze', 'freezing': 'freeze', 'freezes': 'freeze', 'frozen': 'freeze',\n    'chose': 'choose', 'choosing': 'choose', 'chooses': 'choose', 'chosen': 'choose',\n    'rose': 'rise', 'rising': 'rise', 'rises': 'rise', 'risen': 'rise',\n    'arose': 'arise', 'arising': 'arise', 'arises': 'arise', 'arisen': 'arise',\n    'rode': 'ride', 'riding': 'ride', 'rides': 'ride', 'ridden': 'ride',\n    'strode': 'stride', 'striding': 'stride', 'strides': 'stride', 'stridden': 'stride',\n    'woke': 'wake', 'waking': 'wake', 'wakes': 'wake', 'woken': 'wake',\n    'shook': 'shake', 'shaking': 'shake', 'shakes': 'shake', 'shaken': 'shake',\n    'mistook': 'mistake', 'mistaking': 'mistake', 'mistakes': 'mistake', 'mistaken': 'mistake',\n    'forgave': 'forgive', 'forgiving': 'forgive', 'forgives': 'forgive', 'forgiven': 'forgive',\n    'forgot': 'forget', 'forgetting': 'forget', 'forgets': 'forget', 'forgotten': 'forget',\n    'bit': 'bite', 'biting': 'bite', 'bites': 'bite', 'bitten': 'bite',\n    'hid': 'hide', 'hiding': 'hide', 'hides': 'hide', 'hidden': 'hide',\n    'slid': 'slide', 'sliding': 'slide', 'slides': 'slide',\n    'tore': 'tear', 'tearing': 'tear', 'tears': 'tear', 'torn': 'tear',\n    'swore': 'swear', 'swearing': 'swear', 'swears': 'swear', 'sworn': 'swear',\n    'bore': 'bear', 'bearing': 'bear', 'bears': 'bear', 'borne': 'bear', 'born': 'bear',\n    'was': 'be', 'were': 'be', 'being': 'be', 'been': 'be', 'am': 'be', 'is': 'be', 'are': 'be',\n    'had': 'have', 'having': 'have', 'has': 'have',\n    'did': 'do', 'doing': 'do', 'does': 'do', 'done': 'do',\n    'could': 'can', 'would': 'will', 'should': 'shall', 'might': 'may',\n    'sought': 'seek', 'seeking': 'seek', 'seeks': 'seek',\n    'struck': 'strike', 'striking': 'strike', 'strikes': 'strike', 'stricken': 'strike',\n    'wove': 'weave', 'weaving': 'weave', 'weaves': 'weave', 'woven': 'weave',\n    'strove': 'strive', 'striving': 'strive', 'strives': 'strive', 'striven': 'strive',\n    'throve': 'thrive', 'thriving': 'thrive', 'thrives': 'thrive', 'thriven': 'thrive',\n    'dove': 'dive', 'diving': 'dive', 'dives': 'dive',\n    'snuck': 'sneak', 'sneaking': 'sneak', 'sneaks': 'sneak',\n    'awoke': 'awake', 'awaking': 'awake', 'awakes': 'awake', 'awoken': 'awake',\n    'lit': 'light', 'lighting': 'light', 'lights': 'light',\n    'lay': 'lie', 'lying': 'lie', 'lies': 'lie', 'lain': 'lie',  // lie (ëˆ•ë‹¤)\n    'spat': 'spit', 'spitting': 'spit', 'spits': 'spit',\n    'leapt': 'leap', 'leaping': 'leap', 'leaps': 'leap',\n    'dreamt': 'dream', 'dreaming': 'dream', 'dreams': 'dream',\n    'burnt': 'burn', 'burning': 'burn', 'burns': 'burn',\n    'learnt': 'learn', 'learning': 'learn', 'learns': 'learn',\n    'spelt': 'spell', 'spelling': 'spell', 'spells': 'spell',\n    'smelt': 'smell', 'smelling': 'smell', 'smells': 'smell',\n    'spoilt': 'spoil', 'spoiling': 'spoil', 'spoils': 'spoil',\n    'knelt': 'kneel', 'kneeling': 'kneel', 'kneels': 'kneel',\n    'leant': 'lean', 'leaning': 'lean', 'leans': 'lean'\n  };\n  if (irregulars[verb]) return irregulars[verb];\n  \n  // ê·œì¹™ ë™ì‚¬ ë³€í™˜\n  if (verb.endsWith('ing')) {\n    // running -> run, getting -> get, making -> make\n    const base = verb.slice(0, -3);\n    if (base.endsWith(base.slice(-1)) && base.length > 2) {\n      return base.slice(0, -1); // running -> run\n    }\n    if (verb.endsWith('ying')) {\n      return verb.slice(0, -4) + 'y'; // studying -> study\n    }\n    if (verb.endsWith('eing')) {\n      return verb.slice(0, -3); // being -> be\n    }\n    return base.endsWith('e') ? base : (base + 'e').replace(/ee$/, 'e');\n  }\n  if (verb.endsWith('ed')) {\n    const base = verb.slice(0, -2);\n    if (base.endsWith(base.slice(-1)) && base.length > 2) {\n      return base.slice(0, -1);\n    }\n    if (verb.endsWith('ied')) {\n      return verb.slice(0, -3) + 'y';\n    }\n    return base;\n  }\n  if (verb.endsWith('s') && !verb.endsWith('ss')) {\n    if (verb.endsWith('ies')) {\n      return verb.slice(0, -3) + 'y';\n    }\n    if (verb.endsWith('es')) {\n      return verb.slice(0, -2);\n    }\n    return verb.slice(0, -1);\n  }\n  return verb;\n}\n\n// ë™ì‚¬ í™œìš©í˜• íŒ¨í„´ ìƒì„± (Python Lemma ì„œë²„ ì‚¬ìš©)\nasync function getVerbPatternFromServer(verb) {\n  try {\n    const response = await fetch('http://127.0.0.1:8768', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ verb: verb })\n    });\n    const data = await response.json();\n    return data.patterns || [verb];\n  } catch (e) {\n    // ì„œë²„ ì—°ê²° ì‹¤íŒ¨ ì‹œ ê¸°ë³¸ íŒ¨í„´ ë°˜í™˜\n    return getVerbPatternFallback(verb);\n  }\n}\n\n// ì„œë²„ ì—°ê²° ì‹¤íŒ¨ ì‹œ í´ë°± í•¨ìˆ˜\nfunction getVerbPatternFallback(verb) {\n  verb = verb.toLowerCase();\n  const stem = getVerbStem(verb);\n  const patterns = new Set([verb, stem]);\n  \n  // ê¸°ë³¸ ë¶ˆê·œì¹™ ë™ì‚¬ ë§¤í•‘\n  const irregularForms = {\n    'be': ['be', 'am', 'is', 'are', 'was', 'were', 'been', 'being'],\n    'go': ['go', 'goes', 'going', 'went', 'gone'],\n    'arise': ['arise', 'arises', 'arising', 'arose', 'arisen'],\n    'descend': ['descend', 'descends', 'descending', 'descended'],\n    'come': ['come', 'comes', 'coming', 'came'],\n    'get': ['get', 'gets', 'getting', 'got', 'gotten'],\n    'take': ['take', 'takes', 'taking', 'took', 'taken'],\n    'make': ['make', 'makes', 'making', 'made'],\n    'give': ['give', 'gives', 'giving', 'gave', 'given'],\n    'run': ['run', 'runs', 'running', 'ran'],\n    'see': ['see', 'sees', 'seeing', 'saw', 'seen'],\n    'know': ['know', 'knows', 'knowing', 'knew', 'known'],\n    'think': ['think', 'thinks', 'thinking', 'thought'],\n    'find': ['find', 'finds', 'finding', 'found'],\n    'bring': ['bring', 'brings', 'bringing', 'brought'],\n    'hold': ['hold', 'holds', 'holding', 'held'],\n    'stand': ['stand', 'stands', 'standing', 'stood'],\n    'break': ['break', 'breaks', 'breaking', 'broke', 'broken'],\n    'write': ['write', 'writes', 'writing', 'wrote', 'written'],\n    'fall': ['fall', 'falls', 'falling', 'fell', 'fallen'],\n    'keep': ['keep', 'keeps', 'keeping', 'kept'],\n    'leave': ['leave', 'leaves', 'leaving', 'left'],\n    'grow': ['grow', 'grows', 'growing', 'grew', 'grown'],\n    'speak': ['speak', 'speaks', 'speaking', 'spoke', 'spoken'],\n    'draw': ['draw', 'draws', 'drawing', 'drew', 'drawn'],\n    'throw': ['throw', 'throws', 'throwing', 'threw', 'thrown'],\n    'show': ['show', 'shows', 'showing', 'showed', 'shown'],\n    'begin': ['begin', 'begins', 'beginning', 'began', 'begun'],\n    'drive': ['drive', 'drives', 'driving', 'drove', 'driven'],\n    'choose': ['choose', 'chooses', 'choosing', 'chose', 'chosen'],\n    'do': ['do', 'does', 'doing', 'did', 'done'],\n    'have': ['have', 'has', 'having', 'had'],\n    'say': ['say', 'says', 'saying', 'said'],\n    'tell': ['tell', 'tells', 'telling', 'told'],\n  };\n  \n  if (irregularForms[stem]) {\n    for (const form of irregularForms[stem]) {\n      patterns.add(form);\n    }\n  }\n  \n  // ê·œì¹™ì  í™œìš©í˜•\n  if (stem.endsWith('e') && !stem.endsWith('ee')) {\n    patterns.add(stem.slice(0, -1) + 'ing');\n  } else {\n    patterns.add(stem + 'ing');\n  }\n  if (stem.endsWith('e')) {\n    patterns.add(stem + 'd');\n  } else {\n    patterns.add(stem + 'ed');\n  }\n  patterns.add(stem + 's');\n  \n  return [...patterns];\n}\n\n// ë™ê¸° ë²„ì „ (ìºì‹œ ì‚¬ìš©)\nconst verbPatternCache = {};\nfunction getVerbPattern(verb) {\n  verb = verb.toLowerCase();\n  if (verbPatternCache[verb]) {\n    return verbPatternCache[verb];\n  }\n  // í´ë°± ì‚¬ìš© (ë™ê¸° í˜¸ì¶œìš©)\n  const patterns = getVerbPatternFallback(verb);\n  verbPatternCache[verb] = patterns;\n  return patterns;\n}\n\n// êµ¬ë™ì‚¬ í•˜ì´ë¼ì´íŠ¸ í•¨ìˆ˜ (ë™ì‚¬ í™œìš©í˜• + ë¶„ë¦¬ ê°€ëŠ¥ êµ¬ë™ì‚¬ + í•˜ì´í”ˆ êµ¬ë™ì‚¬ ì§€ì›)\nfunction highlightPhrasalVerb(text, phrasalVerb) {\n  if (!phrasalVerb) return text;\n\n  // 1. í•˜ì´í”ˆìœ¼ë¡œ ì—°ê²°ëœ êµ¬ë™ì‚¬ (go-to, run-down ë“±) ë¨¼ì € ì²˜ë¦¬\n  if (phrasalVerb.includes('-')) {\n    const hyphenPattern = new RegExp('\\\\b' + phrasalVerb.replace(/-/g, '[-\\\\s]?') + '\\\\b', 'gi');\n    const highlighted = text.replace(hyphenPattern, '<mark style=\"background:#ffeb3b;padding:2px 4px;border-radius:3px;\">$&</mark>');\n    if (highlighted !== text) return highlighted;\n  }\n\n  const pvWords = phrasalVerb.toLowerCase().split(/[\\s-]+/);\n  if (pvWords.length < 2) {\n    // ë‹¨ì¼ ë‹¨ì–´ì¸ ê²½ìš° ê·¸ëŒ€ë¡œ í•˜ì´ë¼ì´íŠ¸ ì‹œë„\n    const singlePattern = new RegExp('\\\\b' + phrasalVerb + '\\\\b', 'gi');\n    const highlighted = text.replace(singlePattern, '<mark style=\"background:#ffeb3b;padding:2px 4px;border-radius:3px;\">$&</mark>');\n    if (highlighted !== text) return highlighted;\n    return text;\n  }\n\n  const verb = pvWords[0];\n  const particles = pvWords.slice(1);\n\n  // ë™ì‚¬ì˜ ëª¨ë“  í™œìš©í˜• íŒ¨í„´\n  const verbPatterns = getVerbPattern(verb);\n  const verbRegex = '(' + verbPatterns.join('|') + ')';\n\n  // ì „ì¹˜ì‚¬/ë¶€ì‚¬ íŒ¨í„´ (ê° íŒŒí‹°í´ì— ëŒ€í•´ í•˜ì´í”ˆ ë˜ëŠ” ê³µë°± í—ˆìš©)\n  const particleRegex = '(' + particles.join('[\\\\s-]+') + ')';\n\n  // ì‹œë„í•  íŒ¨í„´ë“¤ (ìš°ì„ ìˆœìœ„ ìˆœ)\n  const patternsToTry = [\n    // 1. í•˜ì´í”ˆ ì—°ê²° ë²„ì „ (go-to, set-up ë“±)\n    new RegExp('\\\\b' + verbRegex + '[-]' + particleRegex + '\\\\b', 'gi'),\n    // 2. ë™ì‚¬ + (0-5ë‹¨ì–´) + ì „ì¹˜ì‚¬ (ë¶„ë¦¬ ê°€ëŠ¥ êµ¬ë™ì‚¬: make it through, never miss out)\n    new RegExp('\\\\b' + verbRegex + '(?:[\\\\s,]+\\\\S+){0,5}?[\\\\s,]+' + particleRegex + '\\\\b', 'gi'),\n    // 3. ë™ì‚¬ + ì „ì¹˜ì‚¬ (ë¶™ì–´ìˆëŠ” ê²½ìš°: come forward, take out)\n    new RegExp('\\\\b' + verbRegex + '\\\\s+' + particleRegex + '\\\\b', 'gi'),\n  ];\n\n  for (const pattern of patternsToTry) {\n    const highlighted = text.replace(pattern, '<mark style=\"background:#ffeb3b;padding:2px 4px;border-radius:3px;\">$&</mark>');\n    if (highlighted !== text) return highlighted;\n  }\n\n  // 4. ê° ë™ì‚¬ í™œìš©í˜•ìœ¼ë¡œ ê°œë³„ ì‹œë„ (ë” ë„“ì€ ë²”ìœ„)\n  for (const vp of verbPatterns) {\n    // ë™ì‚¬ë§Œì´ë¼ë„ í•˜ì´ë¼ì´íŠ¸\n    const verbOnlyPattern = new RegExp(\n      '\\\\b' + vp + '(?:[\\\\s,]+\\\\S+){0,6}?[\\\\s,]+' + particles.join('[\\\\s-]+') + '\\\\b',\n      'gi'\n    );\n    const highlighted = text.replace(verbOnlyPattern, '<mark style=\"background:#ffeb3b;padding:2px 4px;border-radius:3px;\">$&</mark>');\n    if (highlighted !== text) return highlighted;\n  }\n\n  // 5. ë§ˆì§€ë§‰ìœ¼ë¡œ ë™ì‚¬ë§Œ í•˜ì´ë¼ì´íŠ¸ (íŒŒí‹°í´ì´ ë¬¸ì¥ì— ì—†ì„ ìˆ˜ ìˆìŒ)\n  for (const vp of verbPatterns) {\n    const verbOnlyPattern = new RegExp('\\\\b' + vp + '\\\\b', 'gi');\n    if (verbOnlyPattern.test(text)) {\n      return text.replace(verbOnlyPattern, '<mark style=\"background:#ffeb3b;padding:2px 4px;border-radius:3px;\">$&</mark>');\n    }\n  }\n\n  return text;\n}\n\nfor (let i = 0; i < sentences.length; i++) {\n  const s = sentences[i];\n  const korean = s.korean || \"\";\n  const baseVerb = s.base_verb || \"\";\n  const phrasalVerb = s.phrasal_verb || \"\";\n  const particle = s.particle || \"\";\n  const literalMeaning = s.literal_meaning || \"\";\n  const idiomaticMeaning = s.idiomatic_meaning || \"\";\n  const coreImage = s.core_image || \"\";\n  const usageNote = s.usage_note || \"\";\n  const alternatives = s.alternatives || [];\n  const formalEquivalent = s.formal_equivalent || \"\";\n  const exampleSentences = s.example_sentences || [];\n\n  // ì›ë³¸ ë¬¸ì¥ + íƒ€ì„ìŠ¤íƒ¬í”„ ê°€ì ¸ì˜¤ê¸°\n  const result = findOriginalSentence(s, s.sentence_index, originalSentences);\n  const originalText = result.text;\n  const timestamp = result.timestamp;\n\n  // êµ¬ë™ì‚¬ í•˜ì´ë¼ì´íŠ¸ëœ ë¬¸ì¥\n  const highlightedText = highlightPhrasalVerb(originalText, phrasalVerb);\n\n  const youtubeLink = `https://www.youtube.com/watch?v=${videoId}&t=${timestamp}s`;\n  const mins = Math.floor(timestamp / 60);\n  const secs = timestamp % 60;\n  const timeStr = `${mins}:${String(secs).padStart(2, '0')}`;\n\n  try {\n    // TTS: ì›ë³¸ ë¬¸ì¥ ì‚¬ìš©\n    const ttsResponse = await this.helpers.httpRequest({\n      method: \"POST\",\n      url: `https://texttospeech.googleapis.com/v1/text:synthesize?key=${GOOGLE_TTS_KEY}`,\n      headers: { \"Content-Type\": \"application/json\" },\n      body: {\n        input: { text: originalText },\n        voice: { languageCode: \"en-US\", name: \"en-US-Neural2-F\" },\n        audioConfig: { audioEncoding: \"MP3\" }\n      },\n      json: true\n    });\n\n    const audioFilename = `youtube_${videoId}_${i+1}.mp3`;\n    await this.helpers.httpRequest({\n      method: \"POST\",\n      url: \"http://127.0.0.1:8765\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: {\n        action: \"storeMediaFile\",\n        version: 6,\n        params: { filename: audioFilename, data: ttsResponse.audioContent }\n      },\n      json: true\n    });\n\n    // ì¹´ë“œ ì•ë©´\n    const front = `\n<div style=\"font-size:18px;line-height:1.8;margin-bottom:15px;\">\n${highlightedText}\n</div>\n[sound:${audioFilename}]\n<br><br>\n<div style=\"background:#e3f2fd;padding:10px;border-radius:8px;display:inline-block;\">\n<span style=\"font-size:24px;font-weight:bold;color:#1565c0;\">${baseVerb}</span>\n<span style=\"font-size:18px;color:#666;\"> + </span>\n<span style=\"font-size:20px;font-weight:bold;color:#43a047;\">${particle}</span>\n<span style=\"font-size:18px;color:#666;\"> = </span>\n<span style=\"font-size:20px;font-weight:bold;color:#e65100;\">${phrasalVerb}</span>\n</div>\n<br><br>\n<a href=\"${youtubeLink}\" style=\"font-size:12px;color:#1976d2;\">ğŸ“º YouTube (${timeStr})</a>\n`;\n\n    const back = `\n<div style=\"font-size:16px;line-height:1.8;\">\n  <div style=\"background:#fff3e0;padding:12px;border-radius:8px;margin-bottom:12px;color:#333;\">\n    <b style=\"color:#e65100;\">ğŸ”¤ ${phrasalVerb}</b>\n  </div>\n\n  <div style=\"margin-bottom:15px;color:#333;\">\n    <b>ğŸ“– í•œêµ­ì–´:</b><br>\n    ${korean}\n  </div>\n\n  <div style=\"background:#e8f5e9;padding:10px;border-radius:8px;margin-bottom:12px;color:#333;\">\n    <b>ğŸ” ì˜ë¯¸ ë³€í™”:</b><br>\n    <span style=\"color:#666;\">ì§ì—­:</span> ${literalMeaning}<br>\n    <span style=\"color:#2e7d32;\">âœ ê´€ìš©:</span> <b>${idiomaticMeaning}</b>\n  </div>\n\n  <div style=\"background:#fce4ec;padding:10px;border-radius:8px;margin-bottom:12px;color:#333;\">\n    <b>ğŸ’¡ í•µì‹¬ ì´ë¯¸ì§€:</b><br>\n    ${coreImage}\n  </div>\n\n  <div style=\"background:#f3e5f5;padding:10px;border-radius:8px;margin-bottom:12px;color:#333;\">\n    <b>ğŸ“ ì‚¬ìš©ë²•:</b><br>\n    ${usageNote}\n  </div>\n\n  ${alternatives && alternatives.length > 0 ? `\n  <div style=\"background:#e3f2fd;padding:10px;border-radius:8px;margin-bottom:12px;color:#333;\">\n    <b>ğŸ”„ ëŒ€ì²´ í‘œí˜„:</b><br>\n    ${alternatives.join(\", \")}\n  </div>` : \"\"}\n\n  ${formalEquivalent ? `\n  <div style=\"background:#efebe9;padding:10px;border-radius:8px;margin-bottom:12px;color:#333;\">\n    <b>ğŸ‘” ê²©ì‹ì²´:</b><br>\n    ${formalEquivalent}\n  </div>` : \"\"}\n\n  ${exampleSentences && exampleSentences.length > 0 ? `\n  <div style=\"background:#fffde7;padding:10px;border-radius:8px;color:#333;\">\n    <b>âœï¸ ì¶”ê°€ ì˜ˆë¬¸:</b><br>\n    <ul style=\"margin:5px 0;padding-left:20px;\">\n      ${exampleSentences.map(s => \"<li>\" + s + \"</li>\").join(\"\")}\n    </ul>\n  </div>` : \"\"}\n</div>\n`;\n\n    const addNoteResponse = await this.helpers.httpRequest({\n      method: \"POST\",\n      url: \"http://127.0.0.1:8765\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: {\n        action: \"addNote\",\n        version: 6,\n        params: {\n          note: {\n            deckName: \"YouTube English\",\n            modelName: \"Basic\",\n            fields: { Front: front, Back: back },\n            options: { allowDuplicate: false },\n            tags: [\"youtube\", \"phrasal-verb\", `base-${baseVerb.toLowerCase()}`, `video-${videoId}`]\n          }\n        }\n      },\n      json: true\n    });\n\n    results.push({\n      success: true,\n      sentence: originalText.slice(0, 50),\n      phrasalVerb: phrasalVerb,\n      highlighted: highlightedText !== originalText,\n      timestamp: timestamp,\n      matchMethod: result.method,\n      noteId: addNoteResponse.result\n    });\n\n  } catch (e) {\n    results.push({ success: false, sentence: originalText.slice(0, 50), error: e.message });\n  }\n}\n\nreturn [{\n  json: {\n    totalSentences: sentences.length,\n    successCount: results.filter(r => r.success).length,\n    highlightedCount: results.filter(r => r.highlighted).length,\n    results: results,\n    videoId: videoId\n  }\n}];"
      },
      "id": "match-timestamps",
      "name": "Process All Sentences",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1800,
        100
      ]
    },
    {
      "parameters": {},
      "id": "manual-trigger",
      "name": "Manual Trigger",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        0,
        200
      ]
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "expression": "0 8 * * *"
            }
          ]
        }
      },
      "id": "schedule-trigger",
      "name": "Daily 8AM",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        0,
        400
      ]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "Find an interesting English learning YouTube video and return only its URL. Make sure to check the used URLs list first and pick a video that hasn't been used before.",
        "options": {
          "systemMessage": "You are a helpful assistant that finds interesting English learning videos on YouTube.\n\nCRITICAL WORKFLOW:\n1. FIRST, use \"Read Used URLs\" tool to get the list of already used YouTube URLs\n2. Remember all those URLs - you must NOT select any video that matches those URLs\n3. Use YouTube search to find a video\n4. Check that the video URL is NOT in the used list\n5. If it's in the used list, search again with a different query\n6. Return ONLY the YouTube URL of a NEW, unused video\n\nTopics to explore: daily conversations, business English, travel, technology, culture, TED talks, interviews, movie scenes\nChoose videos that are 3-15 minutes long and have clear English speech.\n\nIMPORTANT: Always check the used URLs list first. Never return a duplicate URL."
        }
      },
      "id": "ai-agent",
      "name": "AI Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.7,
      "position": [
        300,
        100
      ]
    },
    {
      "parameters": {
        "toolDescription": "Search YouTube for English learning videos. Returns video titles and URLs.",
        "url": "https://www.googleapis.com/youtube/v3/search",
        "sendQuery": true,
        "parametersQuery": {
          "values": [
            {
              "name": "part",
              "valueProvider": "fieldValue",
              "value": "snippet"
            },
            {
              "name": "q"
            },
            {
              "name": "type",
              "valueProvider": "fieldValue",
              "value": "video"
            },
            {
              "name": "maxResults",
              "valueProvider": "fieldValue",
              "value": "5"
            },
            {
              "name": "key",
              "valueProvider": "fieldValue",
              "value": "YOUR_GOOGLE_TTS_API_KEY"
            }
          ]
        },
        "placeholderDefinitions": {
          "values": [
            {
              "name": "q",
              "description": "The search query to find YouTube videos, e.g. 'English conversation practice', 'TED talk motivation'",
              "type": "string"
            }
          ]
        },
        "optimizeResponse": true
      },
      "id": "youtube-tool",
      "name": "YouTube Search",
      "type": "@n8n/n8n-nodes-langchain.toolHttpRequest",
      "typeVersion": 1.1,
      "position": [
        500,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "// AI Agent ì‘ë‹µì—ì„œ YouTube URL ì¶”ì¶œ\nconst output = $input.first().json.output || $input.first().json.text || '';\n\nconst urlPattern = /https?:\\/\\/(?:www\\.)?(?:youtube\\.com\\/watch\\?v=|youtu\\.be\\/)([a-zA-Z0-9_-]{11})/;\nconst match = output.match(urlPattern);\n\nif (match) {\n  return [{ json: { youtubeUrl: match[0], videoId: match[1] } }];\n}\n\nthrow new Error('No YouTube URL found in AI Agent response');"
      },
      "id": "extract-url",
      "name": "Extract URL",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        550,
        100
      ]
    },
    {
      "parameters": {
        "content": "# ğŸ¬ YouTube â†’ Anki ìë™í™”\n\n**ì‹¤í–‰ ë°©ë²•:**\n1. ğŸ–±ï¸ Manual Trigger í´ë¦­\n2. â° ë§¤ì¼ ì˜¤ì „ 8ì‹œ ìë™ ì‹¤í–‰\n3. ğŸ“¨ Webhookìœ¼ë¡œ URL ì§ì ‘ ì „ì†¡",
        "height": 150,
        "width": 280
      },
      "id": "sticky-main",
      "name": "Main Info",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        112,
        32
      ]
    },
    {
      "parameters": {
        "content": "## ğŸ¤– AI Agent\n\nGemini 2.0 Flashê°€ ìë™ìœ¼ë¡œ:\n1. ì˜ì–´ í•™ìŠµ ì£¼ì œ ì„ ì •\n2. YouTube ê²€ìƒ‰\n3. ì ì ˆí•œ ì˜ìƒ URL ë°˜í™˜",
        "height": 140,
        "width": 250
      },
      "id": "sticky-agent",
      "name": "Agent Info",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        624,
        80
      ]
    },
    {
      "parameters": {
        "content": "## â° íŠ¸ë¦¬ê±°\n\n- **Manual**: ìˆ˜ë™ ì‹¤í–‰\n- **Daily 8AM**: ë§¤ì¼ ì˜¤ì „ 8ì‹œ",
        "height": 100,
        "width": 200
      },
      "id": "sticky-trigger",
      "name": "Trigger Info",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        208,
        80
      ]
    },
    {
      "parameters": {
        "modelName": "models/gemini-3-flash-preview",
        "options": {}
      },
      "id": "gemini-model",
      "name": "Gemini 3.0 Flash",
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        300,
        300
      ],
      "credentials": {
        "googlePalmApi": {
          "id": "zxzDD3EmNFfcoBm1",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "youtube-english",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-main",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        0,
        0
      ],
      "webhookId": "youtube-english-hook"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://127.0.0.1:8765",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "{\"action\": \"sync\", \"version\": 6}",
        "options": {}
      },
      "id": "anki-sync-node",
      "name": "Anki Sync",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        2050,
        100
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($input.all().map(item => item.json)) }}"
      },
      "id": "respond-webhook",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        2550,
        200
      ]
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "destinationFieldName": "results",
        "include": "allFieldsExceptBinary"
      },
      "id": "aggregate-results",
      "name": "Aggregate Results",
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        2050,
        300
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "trigger-check",
              "leftValue": "={{ $('Webhook').isExecuted }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-trigger-type",
      "name": "Check Trigger Type",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        2300,
        300
      ]
    },
    {
      "parameters": {
        "toolDescription": "Read the list of already used YouTube URLs from Google Sheets. Call this FIRST before searching YouTube. Returns a list of full YouTube URLs that you must NOT select.",
        "method": "GET",
        "url": "https://docs.google.com/spreadsheets/d/1BecGc6UpSk_0icnBGzb2drasbu4PYiVjt_TQUERoAvs/export?format=csv",
        "authentication": "genericCredentialType",
        "genericAuthType": "oAuth2Api",
        "optimizeResponse": true
      },
      "id": "sheets-read-tool",
      "name": "Read Used URLs",
      "type": "@n8n/n8n-nodes-langchain.toolHttpRequest",
      "typeVersion": 1.1,
      "position": [
        500,
        500
      ],
      "credentials": {
        "oAuth2Api": {
          "id": "YlD8MLYZQq7WitsU",
          "name": "Google Drive account"
        }
      }
    },
    {
      "parameters": {
        "operation": "append",
        "documentId": {
          "__rl": true,
          "value": "1BecGc6UpSk_0icnBGzb2drasbu4PYiVjt_TQUERoAvs",
          "mode": "id"
        },
        "sheetName": {
          "__rl": true,
          "value": "gid=0",
          "mode": "id"
        },
        "columns": {
          "mappingMode": "autoMapInputData",
          "value": {}
        },
        "options": {}
      },
      "id": "save-url-sheets",
      "name": "Save URL to Sheets",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.5,
      "position": [
        2300,
        500
      ],
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "nD3hcemFAkeZMRm5",
          "name": "Google Sheets account"
        }
      },
      "disabled": false
    },
    {
      "parameters": {
        "mode": "manual",
        "duplicateItem": false,
        "assignments": {
          "assignments": [
            {
              "id": "url-assign",
              "name": "url",
              "value": "={{ $('Extract URL').first().json.youtubeUrl }}",
              "type": "string"
            },
            {
              "id": "date-assign",
              "name": "date",
              "value": "={{ new Date().toISOString().split('T')[0] }}",
              "type": "string"
            },
            {
              "id": "video-id-assign",
              "name": "video_id",
              "value": "={{ $('Extract Video ID').first().json.videoId }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        2050,
        500
      ],
      "id": "prepare-url-data",
      "name": "Prepare URL Data"
    },
    {
      "parameters": {
        "jsCode": "// Anki ë±ì„ .apkg íŒŒì¼ë¡œ ë‚´ë³´ë‚´ê¸°\nconst inputData = $input.first().json;\nconst videoId = inputData.videoId || \"unknown\";\nconst results = inputData.results || [];\n\n// ë‚´ë³´ë‚´ê¸° ê²½ë¡œ ì„¤ì • (ë‚ ì§œ + ë¹„ë””ì˜¤ID)\nconst date = new Date().toISOString().slice(0, 10).replace(/-/g, '');\nconst exportPath = `C:/Users/User/Desktop/tcua/exports/YouTube_English_${date}_${videoId}.apkg`;\n\n// AnkiConnectë¡œ ë± ë‚´ë³´ë‚´ê¸°\nconst exportResponse = await this.helpers.httpRequest({\n  method: \"POST\",\n  url: \"http://127.0.0.1:8765\",\n  headers: { \"Content-Type\": \"application/json\" },\n  body: {\n    action: \"exportPackage\",\n    version: 6,\n    params: {\n      deck: \"YouTube English\",\n      path: exportPath,\n      includeSched: false\n    }\n  },\n  json: true\n});\n\nreturn [{\n  json: {\n    ...inputData,\n    exportPath: exportPath,\n    exportSuccess: exportResponse.result === true,\n    exportError: exportResponse.error\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2300,
        100
      ],
      "id": "export-deck-node",
      "name": "Export Anki Deck"
    }
  ],
  "connections": {
    "Extract Video ID": {
      "main": [
        [
          {
            "node": "Get YouTube Transcript",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get YouTube Transcript": {
      "main": [
        [
          {
            "node": "Parse & Group Sentences",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse & Group Sentences": {
      "main": [
        [
          {
            "node": "Filter Practical Sentences (Gemini)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter Practical Sentences (Gemini)": {
      "main": [
        [
          {
            "node": "Process All Sentences",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "Extract URL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract URL": {
      "main": [
        [
          {
            "node": "Extract Video ID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "YouTube Search": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Gemini 3.0 Flash": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Manual Trigger": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          },
          {
            "node": "Delete Old Rows",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Daily 8AM": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process All Sentences": {
      "main": [
        [
          {
            "node": "Anki Sync",
            "type": "main",
            "index": 0
          },
          {
            "node": "Prepare URL Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook Trigger": {
      "main": [
        [
          {
            "node": "Get Used Video IDs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Anki Sync": {
      "main": [
        [
          {
            "node": "Aggregate Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate Results": {
      "main": [
        [
          {
            "node": "Export Anki Deck",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Trigger Type": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "Respond to Webhook": {
      "main": [
        []
      ]
    },
    "Read Used URLs": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Prepare URL Data": {
      "main": [
        [
          {
            "node": "Save URL to Sheets",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Export Anki Deck": {
      "main": [
        [
          {
            "node": "Check Trigger Type",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  }
}